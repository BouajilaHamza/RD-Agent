kg_description_template:
  system: |-
    You are an assistant that extracts structured information from unstructured text.

  user: |-
    Based on the following competition description, please extract the following details:
    1. Competition Type 
    2. Competition Description
    3. Target Description
    4. Competition Features

    Competition Description: {{ competition_descriptions }}

kg_model_background: |-
  You are solving this data science tasks of {{ competition_type }}: 
  {{competition_description}}
  
  We provide an overall pipeline in train.py. Now fill in the provided train.py script to train a {{ competition_type }} model to get a good performance on this task.
  
  The model is a machine learning or deep learning structure designed to predict {{ target_description }}. 
  The data is extracted from the competition dataset, focusing on relevant attributes like {{ competition_features }}.
  ModelType: The type of the model, "XGBoost" for XGBoost model.
  
  The model is defined in the following parts:
  - Name: The name of the model.
  - Description: A description of the model.
  - Architecture: The detailed architecture of the model, such as neural network layers or tree structures.
  
  The model should provide clear and detailed documentation of its architecture and hyperparameters.

kg_model_interface: |-
  Your python code should follow the interface to better interact with the user's system.
  Your code should contain several parts:
  1. The import part: import the necessary libraries.
  2. A class that handles the logic for model selection, training, and prediction, based on the model type specified ("NN", "XGBoost", "RandomForest").
  3. The class should include methods for select(), fit(), and predict().
  4. Use the provided model type to define the model structure and training process:
  
  {% if model_type == "XGBoost" %}
  - The model should be an XGBoost model.
  - Initialize and train the XGBoost model within the fit() method.
  {% elif model_type == "RandomForest" %}
  - The model should be a Random Forest model using scikit-learn.
  - Initialize and train the Random Forest model within the fit() method.
  {% elif model_type == "NN" %}
  - The model should be a Neural Network model using PyTorch.
  - Define the model architecture and train it within the fit() method.
  {% endif %}

  5. The select() function should handle feature selection for both training and prediction phases.
  6. The fit() function should handle the training process, including any validation steps, and print the validation accuracy.
  7. The predict() function should return the predicted probabilities or boolean predictions.

  Below is an example of how your Python code should be structured:

  ```python
  import pandas as pd
  {% if model_type == "XGBoost" %}
  import xgboost as xgb
  from xgboost import DMatrix
  from sklearn.metrics import accuracy_score
  {% elif model_type == "RandomForest" %}
  from sklearn.ensemble import RandomForestClassifier
  from sklearn.metrics import accuracy_score
  {% elif model_type == "NN" %}
  import torch
  import torch.nn as nn
  import torch.optim as optim
  from torch.utils.data import DataLoader, TensorDataset
  {% endif %}

  class Model:
      def __init__(self):
          {% if model_type == "XGBoost" %}
          self.model = None
          {% elif model_type == "RandomForest" %}
          self.model = RandomForestClassifier(n_estimators=100, random_state=32)
          {% elif model_type == "NN" %}
          self.model = nn.Sequential(
              nn.Linear(input_size, hidden_size),
              nn.ReLU(),
              nn.Linear(hidden_size, output_size),
              nn.Sigmoid()
          )
          self.criterion = nn.BCELoss()
          self.optimizer = optim.Adam(self.model.parameters(), lr=0.001)
          {% endif %}

      def select(self, X):
          return X  # Feature selection logic can be added here

      def fit(self, X_train, y_train, X_valid, y_valid):
          X_train = self.select(X_train)
          X_valid = self.select(X_valid)
          
          {% if model_type == "XGBoost" %}
          dtrain = DMatrix(X_train, label=y_train)
          dvalid = DMatrix(X_valid, label=y_valid)
          params = {"objective": "binary:logistic", "eval_metric": "logloss"}
          self.model = xgb.train(params, dtrain, num_boost_round=100)
          y_pred = self.model.predict(dvalid)
          {% elif model_type == "RandomForest" %}
          self.model.fit(X_train, y_train)
          y_pred = self.model.predict(X_valid)
          {% elif model_type == "NN" %}
          train_loader = DataLoader(TensorDataset(X_train, y_train), batch_size=64, shuffle=True)
          valid_loader = DataLoader(TensorDataset(X_valid, y_valid), batch_size=64, shuffle=False)
          
          for epoch in range(10):  # Training loop
              self.model.train()
              for X_batch, y_batch in train_loader:
                  self.optimizer.zero_grad()
                  outputs = self.model(X_batch)
                  loss = self.criterion(outputs, y_batch)
                  loss.backward()
                  self.optimizer.step()
          
          self.model.eval()
          y_pred = []
          with torch.no_grad():
              for X_batch, _ in valid_loader:
                  outputs = self.model(X_batch)
                  y_pred.extend(outputs.squeeze().tolist())
          {% endif %}
          
          accuracy = accuracy_score(y_valid, y_pred)
          print(f"Validation Accuracy: {accuracy:.4f}")
          return self.model

      def predict(self, X):
          X = self.select(X)
          {% if model_type == "XGBoost" %}
          dtest = DMatrix(X)
          y_pred = self.model.predict(dtest)
          {% elif model_type == "RandomForest" %}
          y_pred = self.model.predict(X)
          {% elif model_type == "NN" %}
          self.model.eval()
          with torch.no_grad():
              y_pred = self.model(X).squeeze().tolist()
          {% endif %}
          
          return y_pred

kg_model_output_format: |-
  Your output should be an array with the appropriate number of predictions, each prediction being a single value. The output should be a 2D array with dimensions corresponding to the number of predictions and 1 column (e.g., (8, 1) if there are 8 predictions).
  
kg_model_simulator: |-
  The models will be trained on the competition dataset and evaluated on their ability to predict whether passengers were transported using metrics like accuracy and AUC-ROC. 
  Model performance will be iteratively improved based on feedback from evaluation results.